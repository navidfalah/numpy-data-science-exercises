# -*- coding: utf-8 -*-
"""numpy datascience handbook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16Ue4yHRZN46w2mUSFAEnB3ObxaAPShhJ
"""

import numpy as np

np.__version__

z = 34

L = list(range(10))

L

np.array([1, 4, 2, 5, 3])

np.array([3.14, 4, 2, 3])

np.linspace(0, 1, 5)

np.arange(0, 1, 0.25)

np.eye(4)

np.zeros(10, dtype='int16')

import numpy as np

rng = np.random.default_rng(seed=1701)

x1 = rng.integers(10, size=6)
x2 = rng.integers(10, size=(3, 4))
x3 = rng.integers(10, size=(3, 4, 5))

print("x3 ndim: ", x3.ndim)
print("x3 shape:", x3.shape)
print("x3 size: ", x3.size)
print("dtype: ", x3.dtype)

x1

x1[0]

x2

x2[2]

x2[2][2]

x2[2, 2]

x1

x1[:3]

x1[3:]

x1[::2]

x1[1::2]

x1[2::2]

x1[::-1]

x1[4::-2]

x_list_python = [4, 5, 2, 5, 3, 8]
x_list_numpy = np.array(x_list_python)

slice_list_numpy = x_list_numpy[2:4]
slice_list_numpy

slice_list_numpy[0] = 0
slice_list_numpy

print(x_list_numpy)

x2_sub = x2[:2, :2]
print(x2_sub)

x2_sub[0, 0] = 99
print(x2_sub)

print(x2)

x2_sub_copy = x2[:2, :2].copy()

x2_sub_copy

grid = np.arange(0, 9).reshape(3, 3)

grid

x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
np.concatenate([x, y])

z = np.array([99, 99, 99])
print(np.concatenate([x, y, z]))

x = [1, 2, 3, 99, 99, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])
print(x1, x2, x3)

import numpy as np
rng = np.random.default_rng(seed=1701)

def compute_reciprocals(values):
  output = np.empty(len(values))
  for i in range(len(values)):
    output[i] = 1.0 / values[i]
  return output

values = rng.integers(1, 10, size=5)
compute_reciprocals(values)

# Commented out IPython magic to ensure Python compatibility.
big_array = rng.integers(1, 100, size=1000000)
# %timeit compute_reciprocals(big_array)

print(compute_reciprocals(values))
print(1.0 / values)

# Commented out IPython magic to ensure Python compatibility.
# %timeit (1.0 / big_array)

np.arange(5) / np.arange(1, 6)

np.arange(5)

theta = np.linspace(0, np.pi, 3)

theta

print("theta = ", theta)
print("sin(theta) = ", np.sin(theta))
print("cos(theta) = ", np.cos(theta))
print("tan(theta) = ", np.tan(theta))

sum([3, 5, 2, 4])

mean([4,5, 3])

import numpy as np
from vega_datasets import data

rainfall_mm = np.array(
    data.seattle_weather().set_index('date')['precipitation']['2015']
)

len(rainfall_mm)

rainfall_mm

x = np.array([3, 5, 2])

x<3

np.sum(~( (rainfall_mm <= 10) | (rainfall_mm >= 20) ))

print("Number days without rain: ", np.sum(rainfall_mm == 0))
print("Number days with rain: ", np.sum(rainfall_mm != 0))
print("Days with more than 10 mm: ", np.sum(rainfall_mm > 10))
print("Rainy days with < 5 mm: ", np.sum((rainfall_mm > 0) &(rainfall_mm < 5)))

rainy = (rainfall_mm > 0)
# construct a mask of all summer days (June 21st is the 172nd day)
days = np.arange(365)
summer = (days > 172) & (days < 262)
print("Median precip on rainy days in 2015 (mm): ",
np.median(rainfall_mm[rainy]))
print("Median precip on summer days in 2015 (mm): ",
np.median(rainfall_mm[summer]))
print("Maximum precip on summer days in 2015 (mm): ",
np.max(rainfall_mm[summer]))
print("Median precip on non-summer rainy days (mm):",
np.median(rainfall_mm[rainy & ~summer]))

### fancy indexing

### bining data

rng = np.random.default_rng(seed=1701)
x = rng.normal(size=100)

bins = np.linspace(-5, 5, 20)
bins

counts = np.zeros_like(bins)

counts

i = np.searchsorted(bins, x)

i

np.add.at(counts, i, 1)

counts

import matplotlib.pyplot as plt


plt.plot(bins, counts, linestyle='-');

plt.hist(x, bins)

L = [3, 1, 4, 1, 5, 9, 2, 6]
sorted(L) # returns a sorted copy

import numpy as np

name = ['Alice', 'Bob', 'Cathy', 'Doug']
 age = [25, 45, 37, 19]
 weight = [55.0, 85.5, 68.0, 61.5]

x = np.zeros(4, dtype={'names':('name','age', 'weight'),'formats':('U10', 'i4', 'f8')})

print(x.dtype)

x["name"] = name
x["age"] = age
x["weight"] = weight

x["name"]

x.name

data_rec = x.view(np.recarray)

data_rec

data_rec.name

